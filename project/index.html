<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>LMECA2170: Final project - Delaunay triangulation</title>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="style.css">

		<script src="nodes_coarse.txt"></script> <!-- XXX no clue why this was given to us with a .txt extension -->
		<script type="module" src="matrix.js"></script>
		<script type="module" src="primitives.js"></script>
		<script type="module" src="beach_tree.js"></script>
		<script type="module" src="fortune.js"></script>
		<script type="module" src="priority_queue.js"></script>
		<script type="module" src="render.js"></script>
		<script type="module" src="utils.js"></script>
		<script type="module" src="shader.js"></script>

		<script type="module" src="final.js"></script>
		<script type="module" src="just_nodes.js"></script>
		<script type="module" src="voronoi.js"></script>

		<!-- node shader -->

		<script id="node-vert" type="x-shader/x-vertex">#version 300 es
			precision mediump float;
			layout(location = 0) in vec2 node;
			uniform mat4 u_mvp;

			void main(void) {
				gl_Position = u_mvp * vec4(node, 0.0, 1.0);
			}
		</script>

		<script id="node-frag" type="x-shader/x-fragment">#version 300 es
			precision mediump float;
			out vec4 out_colour;

			void main(void) {
				out_colour = vec4(1.0, 0.9, 0.8, 1.0);
			}
		</script>

		<!-- voronoi shader -->

		<script id="voronoi-vert" type="x-shader/x-vertex">#version 300 es
			precision mediump float;
			layout(location = 0) in vec2 node;
			uniform mat4 u_mvp;

			void main(void) {
				gl_Position = u_mvp * vec4(node, 0.0, 1.0);
			}
		</script>

		<script id="voronoi-frag" type="x-shader/x-fragment">#version 300 es
			precision mediump float;
			out vec4 out_colour;

			void main(void) {
				out_colour = vec4(0.7, 1.0, 0.8, 0.5);
			}
		</script>

		<!-- triangle shader -->

		<script id="tri-vert" type="x-shader/x-vertex">#version 300 es
			precision mediump float;
			layout(location = 0) in vec2 node;
			uniform mat4 u_mvp;

			void main(void) {
				gl_Position = u_mvp * vec4(node, 0.0, 1.0);
			}
		</script>

		<script id="tri-frag" type="x-shader/x-fragment">#version 300 es
			precision mediump float;
			out vec4 out_colour;

			void main(void) {
				out_colour = vec4(1.0, 0.5, 1.0, 0.5);
			}
		</script>
	</head>
	<body>
		<div class="container">
			<h1><strong>LMECA2170</strong>: Delaunay triangulation</h1>

			<h2>Introduction</h2>
			<p>
				This article shows off <strong>Delaunay triangulation</strong> of an arbitrary set of nodes using Fortune's algorithm and the <strong>Voronoi diagram</strong>!
				It also includes interactive demonstrations every step of the way.
			</p>

			<p>
				Throughout every demo, you can click and drag to move the camera around and scroll in and out to zoom.
			</p>

			<h2>The nodes</h2>

			<form enctype="multipart/form-data">
				<input type="file" id="just-nodes-file" hidden />
				<p>
					We start off by just showing the nodes themselves. You can <label class="link" for="just-nodes-file">upload your own nodes file</label>, or click <a id="just-nodes-randomize">here</a> to generate a random set of 5000 nodes.
				</p>
			</form>

			<div class="canvas-container">
				<canvas id="just-nodes-canvas" width="800" height="480"></canvas>
			</div>

			<h2>Voronoi diagram</h2>

			<p>
				The next step is to create the Voronoi diagram of the nodes. This is done by creating a <strong>beach line</strong> and <strong>sweeping</strong> it across the nodes.
				When we encounter a <strong>circle event</strong> or a <strong>site event</strong>, we add line segments to our set of Voronoi line segments, and we update the beach line accordingly.
			</p>

			<p>
				Again, you can upload your own node files, or click <a id="voronoi-randomize">here</a> to generate a random set of nodes.
			</p>

			<div class="canvas-container">
				<canvas id="voronoi-canvas" width="800" height="480"></canvas>
				<p id="voronoi-time">Took - ms for - nodes</p>
			</div>

			<h2>Delaunay triangulation</h2>

			<p>
				The final step of the process is to find the dual of the Voronoi diagram, which is our Delaunay triangulation. Essentially, we connect the sites of two parabolas when they meet at a <strong>circle event</strong>.
			</p>

			<p>
				Click <a>here</a> to upload your own node file, or click <a id="final-randomize">here</a> to generate a random set of nodes.
			</p>

			<div class="canvas-container">
				<canvas id="final-canvas" width="800" height="480"></canvas>
				<p id="final-time">Took - ms for - nodes</p>
			</div>

			<p>
				That's all!
			</p>

			<h2>Extra resources</h2>
			<p>Here are some extra resources relating to Fortune's algorithm, which helped us a lot in developing this site ðŸ˜ƒ</p>

			<ul>
				<li>Tufts University COMP 163 explanation of Fortune's algorithm (<a href="https://www.cs.tufts.edu/comp/163/demos/fortune/">link</a>)</li>
				<li>Jacques Heunis' interactive explanation of Fortune's algorithm (<a href="https://jacquesheunis.com/post/fortunes-algorithm/">link</a>)</li>
			</ul>

			<center>Thank you for reading! ðŸŽ‰</center>
		</div>
	</body>
</html>
